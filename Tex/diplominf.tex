\documentclass[hyperref,german,diplominf]{cgvpub}
%weitere Optionen zum Ergänzen (in eckigen Klammern):
% 
% bibnum	numerische Literaturschlüssel
% final 	für Abgabe	
% lof			Abbildungsverzeichis
% lot			Tabellenverzeichnis
% noproblem	keine Aufgabenstellung
% notoc			kein Inhaltsverzeichnis
% twoside		zweiseitig

\usepackage{lmodern}

\author{Josef Schulz}
\title{Optimierung und Übertragung von Tiefengeometrie für Remote-Visualisierung}
\birthday{20. Oktober 1989}
\placeofbirth{Naumburg (Saale)}
\matno{3658867}
\betreuer{Dr. Sebastian Grottel}
\bibfiles{literatur}

\problem{
In Big-Data-Szenarien in der Visualisierung spielt der Ansatz der Remote-Visualisierung eine zunehmende Rolle.  
Moderne Netzwerktechnologien bieten große Datenübertragungsraten und niedrige Latenzzeiten. Für die 
interaktive Visualisierung sind aber selbst kleinste Latenzzeiten problematisch. Um diese vor dem Benutzer maskieren zu können, kann eine Extrapolation der Darstellung durchgeführt. 
Diese Berechnungen erfordern zusätzlich zum normalen Farbbild weitere Daten, beispielsweise 
ein Tiefenbild und die Daten der verwendeten Kameraeinstellung.
Für die Darstellungsextrapolation werden Farb- und Tiefenbild zusammen interpretiert, beispielsweise als Punktwolke oder Höhenfeldgeometrie. 
Im Rahmen dieser Arbeit soll untersucht werden, wie die Darstellung mittels Höhenfeldgeometrie optimiert  werden kann. 
Ansätze sind hierfür Algorithmen aus der Netzvereinfachung. Zu erwarten sind sowohl 
harte Kanten als auch glatte Verläufe der Tiefenwerte, welche sich in der Netzgeometrie durch 
adaptive Vernetzung mit reduziertem Datenaufwand darstellen lassen.


Dem Szenario der Web-basierten Remote-Visualisierung folgend soll der Web-Browser als
Klient-Komponente eingesetzt werden. Die einzusetzenden Technologien sind HTML5, Javascript, 
WebGL und WebSockets. Entsprechende Javascript-Bibliotheken sollen genutzt 
werden um die Qualität und Wartbarkeit des Quellcodes zu steigern. Für die Server-Komponente darf die Technologie vom Bearbeiter frei gewählt werden.

Zu Beginn der Arbeit wird eine Literatur-Recherche zu Web-basierter Visualisierung und Remote-Visualisierung erfolgen. 
Schwerpunkte  sind hierbei  die  Bild-Extrapolation, Vernetzung 
und Rekonstruktion auf Basis von Tiefenbildern und die Netzoptimierung und -Vereinfachung. 
Im Anschluss an die Literaturrecherche wird ein Konzept für die Implementierung mit dem 
Betreuer abgesprochen und anschließend als prototypische Software umgesetzt. Folgendes 
Szenario dient als Grundlage für dieses Konzept:

Als  Eingabedaten  stehen  mehrere  Datensätze aus  unterschiedlichen  Szenarien  der  wissenschaftlichen Visualisierung zur Verfügung. Für jeden Datensatz sind mehrere Tripel aus Farbbild, Tiefenbild und Kamera-Parameter gegeben.
Die Serverkomponente bereitet einen Datensatz auf und bietet ihn dem Klienten an. Diese Aufbereitung ist vor allem die Generierung einer optimierten  Tiefennetzgeometrie  aus  den  Tiefenbilddaten.  Der  Klient  fordert  Farbbilder,  Kameraeinstellungen und Tiefengeometrie von Tripel-Paaren an.
Konzeptuell wird ein Tripel als aktueller Zustand und das zweite Tripel als Ground-Truth einer Bildextrapolation verstanden. 
Diese können daher auch in dieser Reihenfolge angefordert werden. 
Die Tripel werden zwischen  Klient  und  Server  direkt  per  Sockets/WebSockets  übertragen.
Die Daten des ersten Tripels werden anschließend genutzt um dessen Farbbild in die Ansicht des zweiten Tripels extrapoliert. Hierbei werden vom zweiten Tripel nur die Kameraeinstellung genutzt.
Diese Extrapolation wird  Klient-seitig in WebGL implementiert  damit  alle  Berechnungen  auf  der  GPU 
ausgeführt werden. 
Anschließend wird das extrapolierte Bild mit dem originalen Ground-Truth-Farbbild  aus  dem  zweiten  Tripel  verglichen  um  die  Qualität  der  Extrapolation  zu  bewerten, z.B. durch SSIM.

Die umgesetzte Lösung wird ausführlich evaluiert.
Zentraler Wert ist hierbei die Bildqualität nach der Extrapolation abhängig vom Winkelunterschied zwischen den Kameraeinstellungen und den Parametern der Vereinfachung der Tiefennetzgeometrie. 
Hierfür werden Tripel-Paare aus den Datensätzen und Variationen der Parameter der Algorithmen systematisch 
und automatisiert vermessen. Untersuchungen zum Laufzeitverhalten der Netzoptimierung im Server 
und der Bildextrapolation im Klienten sind optional durchzuführen.
}

\copyrighterklaerung{Hier soll jeder Autor die von ihm eingeholten
Zustimmungen der Copyright-Besitzer angeben bzw. die in Web Press
Rooms angegebenen generellen Konditionen seiner Text- und
Bild"ubernahmen zitieren.}
\acknowledgments{Die Danksagung...}
\abstracten{abstract text english}
\abstractde{ Zusammenfassung Text Deutsch}

\usepackage{pgfplots}
\usepackage{filecontents}

\input{../results/2/512x512_Delaunay/D8/L1.0/I0.0/results.tex}
\input{../results/2/512x512_Delaunay/D8/L1.0/I0.5/results.tex}
\input{../results/2/512x512_Delaunay/D8/L1.0/I1.0/results.tex}
\input{../results/4/512x512_Delaunay/D10/L0.0/I0.0/A0.0/J0.0/_pre/results.tex}

\input{../results/test.tex}

\begin{document}

\chapter{Einleitung}

Bei der Remote-Visualisierung, wird die Bildsynthese und die eigentliche Darstellung voneinander getrennt.
Der Server-Prozess erzeugt und kodiert jedes Bild zu einem kompakten Datenpaket, welches im Anschluss
an den Klient-Prozess gesendet, von diesem dekodiert und auf einem Bildschirm ausgegeben wird.
Remote-Visualisierung ist ein insbesondere für mobile Endgeräte interessantes Konzept,
weil es die Visualisierung von komplexen Szenen auch auf Leistungsarmen Geräten ermöglicht.
Neben Computerspielen, ist die wissenschaftliche Visualisierung ein wichtiges Anwendungsgebiet,
da Datensätze Größenordnungen erreichen, die den Speicher herkömmlicher Desktops, Laptops,
Smartphones etc. bei weitem übersteigen. 
Auch wenn ausreichend Speicher zur Verfügung steht, kann die Übertragung langwierig und teuer werden.
Mit Hilfe der Remote-Visualisierung kann die Visualisierung vom Server übernommen werden und
es muss nicht der komplette Datensatz übertragen werden.
Mit leistungsstarken Serversystemen lassen sich komplexe Beleuchtungsmethoden verwendet,
die mit normalen Endgeräten nicht zu realisieren sind.

Die Latenz bezeichnet in der Netzwerktechnik die Übertragungszeit von einem zum anderen Gerät.
Diese ist in modernen Netzwerken gering, für die Interaktive Visualisierung allerdings immer
noch zu Groß um eine für den Menschen nicht wahrnehmbare flüssige Betrachtung von Szenen
Bild für Bild zu ermöglichen.

Ein Ausweg besteht darin, dass der Klient-Prozess ein bereits empfangenes Bild extrapoliert, 
dadurch kann dem Betrachter ein neues Bild präsentiert werden, obwohl es noch nicht empfangen wurde.
Bei der Bildsynthese des Server-Prozesses entsteht neben dem Farbbild zusätzlich ein Tiefenbild,
das genutzt werden kann um geometrische Informationen an den Klient-Prozess weiter zu reichen
und damit die Extrapolation durchzuführen.

In dieser Arbeit wird aus dem Tiefenbild ein Dreiecksnetz erzeugt, das mit Hilfe des Farbbildes als Textur,
in einer neuen Kameraperspektive gezeichnet wird.
Zu diesem Zweck wurde eine Server- und eine Klient-Komponente entwickelt...


\chapter{Verwandte Arbeiten}

Wessels et al. stellen ein Konzept für den Programmaufbau eines Remote-Visualisierungssystem, 
das auf der Basis von WebSockets arbeitet \cite{DBLP:conf/itng/WesselsPJR11}.
In ihrem System setzt sich der Server-Prozess aus zwei Hauptkomponenten zusammen,
der Visualisierungs-Engine und dem Deamon. Der Deamon übernimmt die Kommunikation
mit dem Klient-Prozess.
Der Klient schickt dabei seine Eingabeinformationen von Maus und Tastatur direkt an den Server,
dieser erzeugt mit diesen ein komprimiertes JPEG Bild, das mit Base64 kodiert und an den Klient
geschickt wird. Mit Hilfe eines HTML5 Canvas wird es dekodiert und dargestellt.

Ein Remote-Visualisierungssystem kann auch als ein Verteiltes-Visualisierungssystem bezeichnet werden. 
Zhefan Jin stellt drei Klassen solcher Systeme vor: sort-first, sort-middle und sort-last
\cite{Jin:2006:RRI:1128923.1128927}.
In einen sort-first System werden geometrische Primitive vor transformiert um ihren Host
zu bestimmen, der die eigentliche Transformation berechnet.
Werden die geometrischen Primitive zwischen der Transformation und der Rasterisierung
an verschiedene Host-Systeme verteilt, dann gehört es zur Klasse der sort-middle Systeme.
In einem sort-last System werden die 

\chapter{Grundlagen}

\section{Extrapolation}

\begin{figure}
	\centering
	\begin{tikzpicture}
	
			\draw(-1.0, 1.0, 1.0) -- (1.0, 1.0, 1.0);
			\draw(-1.0, -1.0, 1.0) -- (1.0, -1.0, 1.0);
	
			\draw(1.0, 1.0, 1.0) -- (1.0, -1.0, 1,0) -- (1.0, -1.0, -1.0) -- (1.0, 1.0, -1.0) -- (1.0, 1.0, 1.0);
			\draw(-1.0, 1.0, 1.0) -- (-1.0, -1.0, 1,0) -- (-1.0, -1.0, -1.0) -- (-1.0, 1.0, -1.0) -- (-1.0, 1.0, 1.0);
			
			\draw(-1.0, 1.0, -1.0) -- (1.0, 1.0, -1.0);
			\draw(-1.0, -1.0, -1.0) -- (1.0, -1.0, -1.0);
			
			% axis
			\draw(0.0, 0.0, 1.0) -> (0.0, 0.0, -1.0);
			\draw(0.0, 1.0, 0.0) -> (0.0,-1.0, 0.0);
			\draw(1.0, 0.0, 0.0) -> (-1.0, 0.0, 0.0);
	
	\end{tikzpicture}
\end{figure}

\section{SSIM}
\section{PSNR}

\chapter{Ergebnisse}

\begin{figure}[htbp]
	\centering
		\includegraphics{../results/2/512x512_Delaunay/D8/L1.0/I1.0/delaunay.png}
		\includegraphics{../results/2/512x512_Delaunay/D8/L0.5/I0.2/delaunay.png}
	\caption{beschriftung}
	\label{fig:diplominf}
\end{figure}

\chapter{Noch mehr Ergebnisse}

\begin{tikzpicture}
\begin{axis}[axis lines = middle, enlargelimits = true]
\addplot[blue, only marks, mark=x] table [x=a, y=p, col sep=comma] {div_data_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}[axis lines = middle, enlargelimits = true]
\addplot[blue, only marks, mark=x] table [x=a, y=p, col sep=comma] {div_data_mean_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}[axis lines = middle, enlargelimits = true]
\addplot[green, mark=x] table [x=a, y=m, col sep=comma] {div_data_mean_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[red, mark=x] table [x=a, y=m, col sep=comma] {div_data_mean_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[blue, mark=x] table [x=a, y=m, col sep=comma] {div_data_mean_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\end{axis}
\end{tikzpicture}


\vspace*{1cm}

\begin{tikzpicture}
\begin{axis}[axis lines = middle, enlargelimits = true]
\addplot[red, only marks, mark=x] table [x=a, y=r, col sep=comma] {div_data_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[green, only marks, mark=x] table [x=a, y=g, col sep=comma] {div_data_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[blue, only marks, mark=x] table [x=a, y=b, col sep=comma] {div_data_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[black, only marks, mark=x] table [x=a, y=m, col sep=comma] {div_data_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}[axis lines = middle, enlargelimits = true, ylabel=t in ms]
\addplot[green] table [x=i, y=min, col sep=comma]{div_duration_info_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[red] table [x=i, y=max, col sep=comma]{div_duration_info_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[black] table [x=i, y=mean, col sep=comma]{div_duration_info_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[blue, mark=x] table [x=i, y=d, col sep=comma]{div_duration_info_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\end{axis}
\end{tikzpicture}

\begin{figure}
	\centering
	\begin{tikzpicture}
		\begin{axis}[view={0}{90}, 
		 			 grid=major,
		 			 xlabel=$T_{internal}$,
		 			 ylabel=$T_{leaf}$,
		 			 point meta min=0.7, point meta max=0.73,
		 			 colormap={greenyellow}{
		   			 	rgb255(0cm)	 =(128,0,0)
		   			 	rgb255(0.5cm) =(255,255,0) 
		   			 	rgb255(1cm) =(0,200,0)
		 			 }, 
		 			 colorbar, 
		 			 enlargelimits=true, 
		 			 xtick={0.0,0.1,...,1.1},
		     		 ytick={0.0,0.1,...,1.1},
		     		 xmajorgrids=true,
		     		 ymajorgrids=true]
		 
		 \addplot3 [only marks, 
		 		   mark=square*, 
		 		   mark size=7,
		 		   ycomb, 
		 		   scatter] file {div.csv};      
		\end{axis}
	\end{tikzpicture}
\end{figure}

\cite*{}
\end{document}