\documentclass[hyperref,german,diplominf]{cgvpub}
%weitere Optionen zum Ergänzen (in eckigen Klammern):
% 
% bibnum	numerische Literaturschlüssel
% final 	für Abgabe	
% lof			Abbildungsverzeichis
% lot			Tabellenverzeichnis
% noproblem	keine Aufgabenstellung
% notoc			kein Inhaltsverzeichnis
% twoside		zweiseitig

\usepackage{lmodern}
%\usepackage[ngerman]{babel}

\author{Josef Schulz}
\title{Optimierung und Übertragung von Tiefengeometrie für Remote-Visualisierung}
\birthday{20. Oktober 1989}
\placeofbirth{Naumburg (Saale)}
\matno{3658867}
\betreuer{Dr. Sebastian Grottel}
\bibfiles{literatur}

\problem{
In Big-Data-Szenarien in der Visualisierung spielt der Ansatz der Remote-Visualisierung eine zunehmende Rolle.  
Moderne Netzwerktechnologien bieten große Datenübertragungsraten und niedrige Latenzzeiten. Für die 
interaktive Visualisierung sind aber selbst kleinste Latenzzeiten problematisch. Um diese vor dem Benutzer maskieren zu können, kann eine Extrapolation der Darstellung durchgeführt. 
Diese Berechnungen erfordern zusätzlich zum normalen Farbbild weitere Daten, beispielsweise 
ein Tiefenbild und die Daten der verwendeten Kameraeinstellung.
Für die Darstellungsextrapolation werden Farb- und Tiefenbild zusammen interpretiert, beispielsweise als Punktwolke oder Höhenfeldgeometrie. 
Im Rahmen dieser Arbeit soll untersucht werden, wie die Darstellung mittels Höhenfeldgeometrie optimiert  werden kann. 
Ansätze sind hierfür Algorithmen aus der Netzvereinfachung. Zu erwarten sind sowohl 
harte Kanten als auch glatte Verläufe der Tiefenwerte, welche sich in der Netzgeometrie durch 
adaptive Vernetzung mit reduziertem Datenaufwand darstellen lassen.


Dem Szenario der Web-basierten Remote-Visualisierung folgend soll der Web-Browser als
Klient-Komponente eingesetzt werden. Die einzusetzenden Technologien sind HTML5, Javascript, 
WebGL und WebSockets. Entsprechende Javascript-Bibliotheken sollen genutzt 
werden um die Qualität und Wartbarkeit des Quellcodes zu steigern. Für die Server-Komponente darf die Technologie vom Bearbeiter frei gewählt werden.

Zu Beginn der Arbeit wird eine Literatur-Recherche zu Web-basierter Visualisierung und Remote-Visualisierung erfolgen. 
Schwerpunkte  sind hierbei  die  Bild-Extrapolation, Vernetzung 
und Rekonstruktion auf Basis von Tiefenbildern und die Netzoptimierung und -Vereinfachung. 
Im Anschluss an die Literaturrecherche wird ein Konzept für die Implementierung mit dem 
Betreuer abgesprochen und anschließend als prototypische Software umgesetzt. Folgendes 
Szenario dient als Grundlage für dieses Konzept:

Als  Eingabedaten  stehen  mehrere  Datensätze aus  unterschiedlichen  Szenarien  der  wissenschaftlichen Visualisierung zur Verfügung. Für jeden Datensatz sind mehrere Tripel aus Farbbild, Tiefenbild und Kamera-Parameter gegeben.
Die Serverkomponente bereitet einen Datensatz auf und bietet ihn dem Klienten an. Diese Aufbereitung ist vor allem die Generierung einer optimierten  Tiefennetzgeometrie  aus  den  Tiefenbilddaten.  Der  Klient  fordert  Farbbilder,  Kameraeinstellungen und Tiefengeometrie von Tripel-Paaren an.
Konzeptuell wird ein Tripel als aktueller Zustand und das zweite Tripel als Ground-Truth einer Bildextrapolation verstanden. 
Diese können daher auch in dieser Reihenfolge angefordert werden. 
Die Tripel werden zwischen  Klient  und  Server  direkt  per  Sockets/WebSockets  übertragen.
Die Daten des ersten Tripels werden anschließend genutzt um dessen Farbbild in die Ansicht des zweiten Tripels extrapoliert. Hierbei werden vom zweiten Tripel nur die Kameraeinstellung genutzt.
Diese Extrapolation wird  Klient-seitig in WebGL implementiert  damit  alle  Berechnungen  auf  der  GPU 
ausgeführt werden. 
Anschließend wird das extrapolierte Bild mit dem originalen Ground-Truth-Farbbild  aus  dem  zweiten  Tripel  verglichen  um  die  Qualität  der  Extrapolation  zu  bewerten, z.B. durch SSIM.

Die umgesetzte Lösung wird ausführlich evaluiert.
Zentraler Wert ist hierbei die Bildqualität nach der Extrapolation abhängig vom Winkelunterschied zwischen den Kameraeinstellungen und den Parametern der Vereinfachung der Tiefennetzgeometrie. 
Hierfür werden Tripel-Paare aus den Datensätzen und Variationen der Parameter der Algorithmen systematisch 
und automatisiert vermessen. Untersuchungen zum Laufzeitverhalten der Netzoptimierung im Server 
und der Bildextrapolation im Klienten sind optional durchzuführen.
}

\copyrighterklaerung{Hier soll jeder Autor die von ihm eingeholten
Zustimmungen der Copyright-Besitzer angeben bzw. die in Web Press
Rooms angegebenen generellen Konditionen seiner Text- und
Bild"ubernahmen zitieren.}
\acknowledgments{Die Danksagung...}
\abstracten{abstract text english}
\abstractde{ Zusammenfassung Text Deutsch}

\usepackage{pgfplots}
\usepackage{filecontents}

\input{../results/2/512x512_Delaunay/D8/L1.0/I0.0/results.tex}
\input{../results/2/512x512_Delaunay/D8/L1.0/I0.5/results.tex}
\input{../results/2/512x512_Delaunay/D8/L1.0/I1.0/results.tex}
\input{../results/4/512x512_Delaunay/D10/L0.0/I0.0/A0.0/J0.0/_pre/results.tex}

\input{../results/test.tex}

\begin{document}

\chapter{Einleitung}

Bei der Remote-Visualisierung, wird die Bildsynthese und die eigentliche Darstellung voneinander getrennt.
Der Server-Prozess erzeugt und kodiert jedes Bild zu einem kompakten Datenpaket, welches im Anschluss
an den Klient-Prozess gesendet, von diesem dekodiert und auf einem Bildschirm ausgegeben wird.
Remote-Visualisierung ist ein insbesondere für mobile Endgeräte interessantes Konzept,
weil es die Visualisierung von komplexen Szenen auch auf Leistungsarmen Geräten ermöglicht.
Neben Computerspielen, ist die wissenschaftliche Visualisierung ein wichtiges Anwendungsgebiet,
da Datensätze Größenordnungen erreichen, die den Speicher herkömmlicher Desktops, Laptops,
Smartphones etc. bei weitem übersteigen. 
Auch wenn ausreichend Speicher zur Verfügung steht, kann die Übertragung langwierig und teuer werden.
Mit Hilfe der Remote-Visualisierung kann die Visualisierung vom Server übernommen werden und
es muss nicht der komplette Datensatz übertragen werden.
Mit leistungsstarken Serversystemen lassen sich komplexe Beleuchtungsmethoden verwendet,
die mit normalen Endgeräten nicht zu realisieren sind.

Die Latenz bezeichnet in der Netzwerktechnik die Übertragungszeit von einem zum anderen Gerät.
Diese ist in modernen Netzwerken gering, für die Interaktive Visualisierung allerdings immer
noch zu Groß um eine für den Menschen nicht wahrnehmbare flüssige Betrachtung von Szenen
Bild für Bild zu ermöglichen.

Ein Ausweg besteht darin, dass der Klient-Prozess ein bereits empfangenes Bild extrapoliert, 
dadurch kann dem Betrachter ein neues Bild präsentiert werden, obwohl es noch nicht empfangen wurde.
Bei der Bildsynthese des Server-Prozesses entsteht neben dem Farbbild zusätzlich ein Tiefenbild,
das genutzt werden kann um geometrische Informationen an den Klient-Prozess weiter zu reichen
und mit Hilfe dieser Extrapolation durchzuführen.
Aus dem Tiefenbild wir dazu ein Dreiecksnetz erzeugt, das mit dem Farbbild als Textur
vom Klient aus der neuen Kameraperspektive synthetisiert wird.

Zu diesem Zweck wurde eine Server- und eine Klient-Komponente entwickelt, die mit
Hilfe des WebSocket-Protokolls Daten untereinander austauschen.
Der Klient basiert auf JavaScript und nutzt für die Bildextrapolation WebGl.
Die Qualität der Darstellungen werden mit Hilfe von Ground-Truth-Daten überprüft.
Zum Vergleich wird der PSNR und der SSIM \cite{Wang04imagequality} der Bildpaare bestimmt und evaluiert.

Im Folgenden werden existierende Konzepte und Ideen vorgestellt.


\chapter{Verwandte Arbeiten}

Einen Überblick über Architekturen und Methoden der interaktiven Remote-Visualisierung geben Shu Shi et al. \cite{Shi:2015:SIR:2775083.2719921}.
Zum zentralen Problem ihrer Arbeit, wird die Latenz und die effiziente Übertragung der Daten vom Server zum Klient.
Lösungen hängen vom Anwendungsfall ab, in \textit{THIN}-Systemen besteht die Aufgabe in der Übertragung von
2D Informationen, mit denen sich zum Beispiel Desktop-Anwendungen Fernsteuern lassen.
Als Beispiele dienen SLIM \cite{Schmidt:1999:IPS:319344.319154} und THiNC \cite{Baratto:2005:TVD:1095809.1095837}.
Die Übertragung der Daten wurde in beiden Systemen für den Einsatz von 2D Grafiken optimiert.
Ein Vorteil bei diesen Anwendungen besteht darin, dass nur relativ kleine Änderungen
tatsächlich übertragen werden müssen, wenn sich zum Beispiel ein Fenster ändert muss auch
nur diese Änderung zum Klient übertragen werden.
Zur Verbesserung der Latenz wird von Shu Shi et al. die Bildextrapolation vorgeschlagen.
Diese kann durch die zusätzliche Übertragung von Tiefenbildern oder Dreiecksnetzen erreicht werden.
Bei der Bildsynthese auf dem Klient-System, entsteht eine Menge von Artefakten, diese kann durch Verzerrung und Verformung der Geometrieinformationen verkleinert werden, durch sogenanntes \textit{Warping} \cite{1331221}, \cite{4810995}.
Wenn eine Extrapolation der Bilder, durch den Klient, aus Hardware-Gründen nicht möglich ist,
können auch die nächst möglichen Bewegungen geschätzt werden und deren Ergebnisse werden mit übertragen.
Zur Verbesserung der Qualität werden deshalb in vielen Anwendungen die Bewegungsmöglichkeiten
des Nutzers auf Pfade oder Aussichtspunkte beschränkt.

\section{Architektur}

Ein spezielles Remote-Visualisierungssystem haben Peter Eisert und Philipp Fechteler 
für Computerspiele entwickelt \cite{Eisert07remoterendering}.
Ihr System kommt ohne Beschränkung der Bewegungsfreiheit aus.
Sie haben sich dafür zwei Ansätze zunutze gemacht. 
Im ersten Ansatz erzeugt der Server die fertigen Bilder,
welche mit Video-Codecs codiert und an den Klient gestreamt werden.
Im zweiten Ansatz, werden Zeicheninstruktionen an den Klient gestreamt, welcher mit diesen
das Ergebnissbild produziert.
Ihr System ist für den Einsatz im lokalen Netzwerk konstruiert.

Wessels et al. stellen eine Konzeption für den Programmaufbau eines interaktiven Remote-Visualisierungssystem basierend auf dem WebSocket-Protokoll vor \cite{DBLP:conf/itng/WesselsPJR11}.
In ihrem System besteht der Server-Prozess aus zwei Hauptkomponenten,
der Visualisierungs-Engine und dem Deamon. 
Während die Visualisierungs-Engine für die Bildsynthese zuständig ist, 
übernimmt der Deamon die Kommunikation mit dem Klient-Prozess.
Der Klient schickt dabei seine Eingabeinformationen von Maus und Tastatur direkt an den Server.
Dieser wertet die Daten aus und erzeugt darauf hin ein mit JPEG komprimiertes Bild, das mit Base64 kodiert wird und schließlich an den Klient-Prozess geschickt wird. 
Dieser kann das Bild nativ mit Hilfe eines HTML5 Canvas dekodieren und darstellen.
Ihr System wird zur Grundlage dieser Arbeit.

\section{Extrapolation}

Die Grundidee das Problem der Latenz mit Bildexploration in den Griff zu bekommen wurde in der Arbeit von Palomo et al. betrachtet \cite{Palomo:2010:EAD:1900179.1900236}.

Das erzeugte Tiefenbild lässt sich 
Pauly et al. \cite{Pauly:2002:ESP:602099.602123}

Simon Stegmaier \cite{Stegmaier02ageneric} 
A Generic Solution for Hardware-Accelerated Remote Visualization

\section{Kompression}

Gabriel Taubin und Jarek Rossignac haben ein Algorithmus zur Erzeugung und effizienten Kodierung von Dreiecksstreifen aus Dreiecksnetzen entwickelt \cite{Taubin:1998:GCT:274363.274365}.
Dazu konstruiert ihr Algorithmus Spannbäume über dem Netz, die zur Erzeugung möglichst großer
Dreiecksstreifen genutzt werden. Die Kompression kann wahlweise verlustfrei oder verlustbehaftet
durchgeführt werden. Typische Kompressionsraten werden mit 1:50 angegeben.

Eine weitere Arbeit die sich mit der Kompression von Dreiecksnetzen und einer kompakten Repräsentation
von diesen beschäftigt wurde Stefan Gumhold und Wolfgang Straßer geschrieben \cite{Gumhold:1998:RTC:280814.280836}.
Kompression und Dekompression sind echtzeitfähig.

Michael Deering hat ebenfalls ein Geometrisches Kompressionsverfahren entwickelt. \cite{Deering:1995:GC:218380.218391}

Federico Ponchio  und Matteo Dellepiane \cite{Ponchio:2015:FDW:2775292.2775308}
Fast decompression for web-based view-dependent 3D rendering



Diplomarbeit mädcheninformatiker Effiziente Datenübertragung von Modellen und
Texturen für die Verwendung in WebGL
Stefan Wagner noch kein cite



WEB-BASED VISUALISATION OF ON-SET POINT CLOUD
DATA Alun Evans et al \cite{Evans:2014:WVO:2668904.2668937}

planarer scheiß \cite{Ma13ecmr}

Ein Remote-Visualisierungssystem als ein verteiltes System betrachtet werden.
Zhefan Jin stellt drei Klassen solcher Systeme vor \cite{Jin:2006:RRI:1128923.1128927}.
Diese unterscheiden sich anhand der Verteilung ihrer Daten auf unterschiedliche Host-Systeme.
Dabei können Zeicheninstruktionen, Attribute, oder Bilder von einem Knoten zum anderen weiter gereicht werden.
Auch bei einfache Remote-Visualisierungssysteme unterscheiden sich an Hand der Daten die übertragen werden.

\chapter{Grundlagen}

In diesem Kapitel soll es um die Grundlagen der Arbeit gehen. Es wird
vorgestellt wie ein bestehendes Dreiecksnetz aus einer neuen Perspektive
gezeichnet wird und wie die Methoden zum Bildvergleich im Detail funktionieren.

\section{Extrapolation}

Bei dem Zeichenvorgang auf dem Server entsteht ein Farbbild und ein Tiefenbild.
Das Tiefenbild wurde mit einer Farbtiefe von 16bit erzeugt und ist die Ausgangsbasis
für die Bildextrapolation. 
Da aus diesem ein Dreiecksnetz erzeugt wird, welche das Farbbild als Textur verwendet,
und zur Erzeugung neuer Ansichten genutzt wird.
Um das Verfahren besser zu verständlich zu machen,
wird zunächst die Vertex-Transformation näher betrachtet, zu Verdeutlichung der
Zusammenhänge dient die folgende Abbildung:

\begin{figure}[h]
	\begin{tikzpicture}
		\begin{scope}[auto, every node/.style={minimum size=5em, align=center}]
			\node[draw] (A) at (0,0) {Vertex};
			\node[draw] (B) at (4,0) {ModellKamera-\\Matrix};
			
			\node[draw] (C) at (8,0) {Projektion-\\Matrix};
			\node[draw] (D) at (12,0) {Viewport-\\Matrix};
		\end{scope}
		
			\node (B1) at (6,0) {};
			\node (B2) at (6,-2) {Kamera-Koordinaten};
			
			\node (C1) at (10,0) {};
			\node (C2) at (10,-2) {NDC};
			
			\draw[->, line width=1mm] (A) edge (B);
			\draw[->, line width=1mm] (B) edge (C);
			\draw[->, line width=1mm] (C) edge (D);
			
			\draw[->] (B1) edge (B2);
			\draw[->] (C1) edge (C2);
	\end{tikzpicture}
	\centering
	\label{fig:Transformationspipeline}
	\caption{Die Abbildung zeigt die Transformationspipeline, mit deren Hilfe die Vertices
			 auf den Bildschirm abgebildet werden.}
\end{figure}

Die Eingabe der Transformationspipeline ist ein Vertex. Jeder Vertex besteht aus einer x-, y- und einer z-Komponente. 
Die Vertices sind im Modell-Koordinatensystem definiert, das bedeutet, dass der Ursprung
dieses Koordinatensystems das Zentrum des Modells ist.
Durch die Multiplikation mit der Modell-Matrix werden die Vertices in das Weltkoordinatensystem
projiziert.
Um die Koordinaten aus dem Weltkoordinatensystem in das Kamera-Koordinatensystem abzubilden genügt die Multiplikation mit der Kameramatrix.
In der Abbildung \ref{fig:Transformationspipeline} wurde die Modell- und die Kamera-Matrix
zur ModellKamera-Matrix zusammengefasst.
Werden die Vertices, die sich im Kamerakoordinatensystem befinden mit der Projektionsmatrix
multipliziert, dann werden diese in \textit{normalized-device-coordinates}, 
kurz NDC umgewandelt.
Normalisierte-Geräte-Koordinaten haben für die x-,y- und z-Komponente den Wertebereich von
$-1.0$ bis $1.0$. Durch die Multiplikation mit der Viewport-Matrix werden die x- und
 y-Komponente auf die Bildschirmkoordinaten abgebildet.

Um aus dem Tiefenbild normalisierte Gerätekoordinaten zu erhalten, müssen die x- und y-Koordinaten der Pixel durch die Auflösung geteilt werden.
Die Farbwerte des Tiefenbildes liegen im Bereich von $0.0$ bis $1.0$. Je größer der
Wert ist, umso weiter ist ein Pixel von der Bildschirmebene entfernt.
Die Farbwerte müssen ebenfalls in den Wertebereich von $-1.0$ bis $1.0$ überführt werden.

Damit aus den normalisierten Gerätekoordinaten wieder Modellkoordinaten werden,
reicht es aus diese mit der invertierten ModellKameraProjektionsmatrix zu multiplizieren.
Die daraus resultierenden Vertices, lassen sich erneut mit der Transformationspipeline
abbilden, auf diese Weise lassen sich die Koordinaten des einen Bildes in die eines
anderen überführen.

\section{Delaunay-Triangulierung}

Die Delaunay-Triangulierung ist ein Verfahren um ein Dreiecknetz aus einer Menge von
Punkten $p \in \mathbb{R}^{2}$ zu erzeugen.
Dabei wird für jedes Dreieck ein Umkreis erzeugt, innerhalb dessen keine Punkte eines anderen
Dreiecks enthalten sein dürfen.
Jedes Dreieck des zu erzeugenden Netzes muss diese Bedingung erfüllen.
Das Resultat dieser Forderung ist die maximierte Innenwinkelsumme aller Dreiecke.
Für eine gegebene Punktmenge, ist die Lösung nicht eindeutig, es kann verschiedene
Netzkonfigurationen geben, welche die Forderung erfüllen.



\section{PSNR}

\begin{equation}
	MSE = \frac{1}{mn} \sum\limits_{i=0}^{m-1} \sum\limits_{j=0}^{n-1}[I(i, j) - K(i, j)]^2
\end{equation}

\begin{align}
PSNR &= 10 \times \log_{10} \left( \frac{MAX^2_I}{MSE} \right) \\
	 &= 20 \times \log_{10} \left( \frac{MAX_I}{\sqrt{MSE}} \right) \\
	 &= 20 \times \log_{10} (MAX_I) - 10 \times \log_{10} (MSE)
\end{align}

\section{SSIM}

Image Quality Assessment: From Error Visibility to
Structural Similarity \cite{Wang04imagequality}

\begin{equation}
	SSIM(x, y) = [l(x,y)]^\alpha \times [c(x, y)]^\beta \times [s(x, y)]^\gamma
\end{equation}

$\alpha > 0, \beta > 0, \gamma > 0$

\begin{equation}
	SSIM(x, y) = \frac{(2 \mu_x \mu_y + C_1)(2\sigma_{xy} + C_2)}{(\mu^2_x + \mu^2_y + C_1)(\sigma^2_x + \sigma^2_y + C_2)}
\end{equation}

\begin{align}
	\mu_x &= \sum\limits_{i=1}^{N} w_i x_i \\
	\sigma_x &= \left( \sum\limits_{i=1}^{N} w_i(x_i - \mu_x)^2 \right)^\frac{1}{2} \\
	\sigma_xy &= \sum\limits_{i=1}^{N} w_i(x_i - \mu_x)(y_i - \mu_y)
\end{align}

\begin{equation}
	MSSIM(X, Y) = \frac{1}{M} \sum\limits_{j=1}^{M} SSIM(x_j, y_j)
\end{equation}

\chapter{Methodik und Umsetzung}

Die Aufgabe bestand in der Entwicklung eines Remote-Visualisierungssystems.
Der Server und der Klient kommunizieren über das WebSocket-Protokoll miteinander.
Als Grundlage für die Klient-Anwendung dient HTML5, JavaScript und WebGl,
was den Vorteil hat, das dieser Plattform-unabhängig ist.

Die Aufgabe das Servers besteht darin, alle Szenen zu laden.
In diesem Anwendungsfall entspricht eine Szene einer Liste von Paaren, die jeweils
aus einem Farb- und einem Tiefenbild bestehen.

\section{Vollvernetzung}
\section{Delaunay-Triangulierung}

\chapter{Ergebnisse}

\chapter{Diskussion}

\chapter{Zusammenfassung}

\chapter{Ausblick}

\begin{figure}[htbp]
	\centering
		\includegraphics{../results/2/512x512_Delaunay/D8/L1.0/I1.0/delaunay.png}
		\includegraphics{../results/2/512x512_Delaunay/D8/L0.5/I0.2/delaunay.png}
	\caption{beschriftung}
	\label{fig:diplominf}
\end{figure}

\chapter{Noch mehr Ergebnisse}

\begin{tikzpicture}
\begin{axis}[axis lines = middle, enlargelimits = true]
\addplot[blue, only marks, mark=x] table [x=a, y=p, col sep=comma] {div_data_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}[axis lines = middle, enlargelimits = true]
\addplot[blue, only marks, mark=x] table [x=a, y=p, col sep=comma] {div_data_mean_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}[axis lines = middle, enlargelimits = true]
\addplot[green, mark=x] table [x=a, y=m, col sep=comma] {div_data_mean_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[red, mark=x] table [x=a, y=m, col sep=comma] {div_data_mean_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[blue, mark=x] table [x=a, y=m, col sep=comma] {div_data_mean_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\end{axis}
\end{tikzpicture}


\vspace*{1cm}

\begin{tikzpicture}
\begin{axis}[axis lines = middle, enlargelimits = true]
\addplot[red, only marks, mark=x] table [x=a, y=r, col sep=comma] {div_data_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[green, only marks, mark=x] table [x=a, y=g, col sep=comma] {div_data_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[blue, only marks, mark=x] table [x=a, y=b, col sep=comma] {div_data_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[black, only marks, mark=x] table [x=a, y=m, col sep=comma] {div_data_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}[axis lines = middle, enlargelimits = true, ylabel=t in ms]
\addplot[green] table [x=i, y=min, col sep=comma]{div_duration_info_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[red] table [x=i, y=max, col sep=comma]{div_duration_info_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[black] table [x=i, y=mean, col sep=comma]{div_duration_info_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[blue, mark=x] table [x=i, y=d, col sep=comma]{div_duration_info_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\end{axis}
\end{tikzpicture}

\begin{figure}
	\centering
	\begin{tikzpicture}
		\begin{axis}[view={0}{90}, 
		 			 grid=major,
		 			 xlabel=$T_{internal}$,
		 			 ylabel=$T_{leaf}$,
		 			 point meta min=0.7, point meta max=0.73,
		 			 colormap={greenyellow}{
		   			 	rgb255(0cm)	 =(128,0,0)
		   			 	rgb255(0.5cm) =(255,255,0) 
		   			 	rgb255(1cm) =(0,200,0)
		 			 }, 
		 			 colorbar, 
		 			 enlargelimits=true, 
		 			 xtick={0.0,0.1,...,1.1},
		     		 ytick={0.0,0.1,...,1.1},
		     		 xmajorgrids=true,
		     		 ymajorgrids=true]
		 
		 \addplot3 [only marks, 
		 		   mark=square*, 
		 		   mark size=7,
		 		   ycomb, 
		 		   scatter] file {div.csv};      
		\end{axis}
	\end{tikzpicture}
\end{figure}

\begin{figure}[h]
	\begin{tikzpicture}
		\begin{scope}[auto, every node/.style={minimum width=15em}]
		 
		\node[draw, fill=lightgray] (A) at (0,0) {Vertex Data};
		
		\node[draw, fill=yellow]	(B) at (0,-1) {Vertex Shader};
		
		\node[draw, fill=lightgray] (C) at (0, -2) {Primitive Assembly};

		\node[draw, fill=lightgray] (D) at (0,-3) {Rasterization};
		
		\node[draw, fill=yellow] 	(E) at (0,-4) {Fragment Shader};
		
		\node[draw, fill=lightgray] (F) at (0,-5) {Per-Fragment Operations};
		
		\node[draw, fill=lightgray] (G) at (0,-6) {Framebuffer};	

		\draw[->, line width=1mm] (A) edge (B);
		\draw[->, line width=1mm] (B) edge (C);
		\draw[->, line width=1mm] (C) edge (D);
		\draw[->, line width=1mm] (D) edge (E);
		\draw[->, line width=1mm] (E) edge (F);
		\draw[->, line width=1mm] (F) edge (G);
		
		\end{scope}
	\end{tikzpicture}
	\centering
\end{figure}

\cite*{}
\end{document}