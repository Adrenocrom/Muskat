\documentclass[hyperref,german,diplominf]{cgvpub}
%weitere Optionen zum Ergänzen (in eckigen Klammern):
% 
% bibnum	numerische Literaturschlüssel
% final 	für Abgabe	
% lof			Abbildungsverzeichis
% lot			Tabellenverzeichnis
% noproblem	keine Aufgabenstellung
% notoc			kein Inhaltsverzeichnis
% twoside		zweiseitig

\usepackage{lmodern}
%\usepackage[ngerman]{babel}

\author{Josef Schulz}
\title{Optimierung und Übertragung von Tiefengeometrie für Remote-Visualisierung}
\birthday{20. Oktober 1989}
\placeofbirth{Naumburg (Saale)}
\matno{3658867}
\betreuer{Dr. Sebastian Grottel}
\bibfiles{literatur}

\problem{
In Big-Data-Szenarien in der Visualisierung spielt der Ansatz der Remote-Visualisierung eine zunehmende Rolle.  
Moderne Netzwerktechnologien bieten große Datenübertragungsraten und niedrige Latenzzeiten. Für die 
interaktive Visualisierung sind aber selbst kleinste Latenzzeiten problematisch. Um diese vor dem Benutzer maskieren zu können, kann eine Extrapolation der Darstellung durchgeführt. 
Diese Berechnungen erfordern zusätzlich zum normalen Farbbild weitere Daten, beispielsweise 
ein Tiefenbild und die Daten der verwendeten Kameraeinstellung.
Für die Darstellungsextrapolation werden Farb- und Tiefenbild zusammen interpretiert, beispielsweise als Punktwolke oder Höhenfeldgeometrie. 
Im Rahmen dieser Arbeit soll untersucht werden, wie die Darstellung mittels Höhenfeldgeometrie optimiert  werden kann. 
Ansätze sind hierfür Algorithmen aus der Netzvereinfachung. Zu erwarten sind sowohl 
harte Kanten als auch glatte Verläufe der Tiefenwerte, welche sich in der Netzgeometrie durch 
adaptive Vernetzung mit reduziertem Datenaufwand darstellen lassen.


Dem Szenario der Web-basierten Remote-Visualisierung folgend soll der Web-Browser als
Klient-Komponente eingesetzt werden. Die einzusetzenden Technologien sind HTML5, Javascript, 
WebGL und WebSockets. Entsprechende Javascript-Bibliotheken sollen genutzt 
werden um die Qualität und Wartbarkeit des Quellcodes zu steigern. Für die Server-Komponente darf die Technologie vom Bearbeiter frei gewählt werden.

Zu Beginn der Arbeit wird eine Literatur-Recherche zu Web-basierter Visualisierung und Remote-Visualisierung erfolgen. 
Schwerpunkte  sind hierbei  die  Bild-Extrapolation, Vernetzung 
und Rekonstruktion auf Basis von Tiefenbildern und die Netzoptimierung und -Vereinfachung. 
Im Anschluss an die Literaturrecherche wird ein Konzept für die Implementierung mit dem 
Betreuer abgesprochen und anschließend als prototypische Software umgesetzt. Folgendes 
Szenario dient als Grundlage für dieses Konzept:

Als  Eingabedaten  stehen  mehrere  Datensätze aus  unterschiedlichen  Szenarien  der  wissenschaftlichen Visualisierung zur Verfügung. Für jeden Datensatz sind mehrere Tripel aus Farbbild, Tiefenbild und Kamera-Parameter gegeben.
Die Serverkomponente bereitet einen Datensatz auf und bietet ihn dem Klienten an. Diese Aufbereitung ist vor allem die Generierung einer optimierten  Tiefennetzgeometrie  aus  den  Tiefenbilddaten.  Der  Klient  fordert  Farbbilder,  Kameraeinstellungen und Tiefengeometrie von Tripel-Paaren an.
Konzeptuell wird ein Tripel als aktueller Zustand und das zweite Tripel als Ground-Truth einer Bildextrapolation verstanden. 
Diese können daher auch in dieser Reihenfolge angefordert werden. 
Die Tripel werden zwischen  Klient  und  Server  direkt  per  Sockets/WebSockets  übertragen.
Die Daten des ersten Tripels werden anschließend genutzt um dessen Farbbild in die Ansicht des zweiten Tripels extrapoliert. Hierbei werden vom zweiten Tripel nur die Kameraeinstellung genutzt.
Diese Extrapolation wird  Klient-seitig in WebGL implementiert  damit  alle  Berechnungen  auf  der  GPU 
ausgeführt werden. 
Anschließend wird das extrapolierte Bild mit dem originalen Ground-Truth-Farbbild  aus  dem  zweiten  Tripel  verglichen  um  die  Qualität  der  Extrapolation  zu  bewerten, z.B. durch SSIM.

Die umgesetzte Lösung wird ausführlich evaluiert.
Zentraler Wert ist hierbei die Bildqualität nach der Extrapolation abhängig vom Winkelunterschied zwischen den Kameraeinstellungen und den Parametern der Vereinfachung der Tiefennetzgeometrie. 
Hierfür werden Tripel-Paare aus den Datensätzen und Variationen der Parameter der Algorithmen systematisch 
und automatisiert vermessen. Untersuchungen zum Laufzeitverhalten der Netzoptimierung im Server 
und der Bildextrapolation im Klienten sind optional durchzuführen.
}

\copyrighterklaerung{Hier soll jeder Autor die von ihm eingeholten
Zustimmungen der Copyright-Besitzer angeben bzw. die in Web Press
Rooms angegebenen generellen Konditionen seiner Text- und
Bild"ubernahmen zitieren.}
\acknowledgments{Die Danksagung...}
\abstracten{abstract text english}
\abstractde{ Zusammenfassung Text Deutsch}

\usepackage{pgfplots}
\usepackage{filecontents}

\input{../results/2/512x512_Delaunay/D8/L1.0/I0.0/results.tex}
\input{../results/2/512x512_Delaunay/D8/L1.0/I0.5/results.tex}
\input{../results/2/512x512_Delaunay/D8/L1.0/I1.0/results.tex}
\input{../results/4/512x512_Delaunay/D10/L0.0/I0.0/A0.0/J0.0/_pre/results.tex}

\input{../results/test.tex}

\begin{document}

\chapter{Einleitung}

Bei der Remote-Visualisierung, wird die Bildsynthese und die eigentliche Darstellung voneinander getrennt.
Der Server-Prozess erzeugt und kodiert jedes Bild zu einem kompakten Datenpaket, welches im Anschluss
an den Klient-Prozess gesendet, von diesem dekodiert und auf einem Bildschirm ausgegeben wird.
Remote-Visualisierung ist ein insbesondere für mobile Endgeräte interessantes Konzept,
weil es die Visualisierung von komplexen Szenen auch auf Leistungsarmen Geräten ermöglicht.
Neben Computerspielen, ist die wissenschaftliche Visualisierung ein wichtiges Anwendungsgebiet,
da Datensätze Größenordnungen erreichen, die den Speicher herkömmlicher Desktops, Laptops,
Smartphones etc. bei weitem übersteigen. 
Auch wenn ausreichend Speicher zur Verfügung steht, kann die Übertragung langwierig und teuer werden.
Mit Hilfe der Remote-Visualisierung kann die Visualisierung vom Server übernommen werden und
es muss nicht der komplette Datensatz übertragen werden.
Mit leistungsstarken Serversystemen lassen sich komplexe Beleuchtungsmethoden verwendet,
die mit normalen Endgeräten nicht zu realisieren sind.

Die Latenz bezeichnet in der Netzwerktechnik die Übertragungszeit von einem zum anderen Gerät.
Diese ist in modernen Netzwerken gering, für die Interaktive Visualisierung allerdings immer
noch zu Groß um eine für den Menschen nicht wahrnehmbare flüssige Betrachtung von Szenen
Bild für Bild zu ermöglichen.

Ein Ausweg besteht darin, dass der Klient-Prozess ein bereits empfangenes Bild extrapoliert, 
dadurch kann dem Betrachter ein neues Bild präsentiert werden, obwohl es noch nicht empfangen wurde.
Bei der Bildsynthese des Server-Prozesses entsteht neben dem Farbbild zusätzlich ein Tiefenbild,
das genutzt werden kann um geometrische Informationen an den Klient-Prozess weiter zu reichen
und mit Hilfe dieser Extrapolation durchzuführen.
Aus dem Tiefenbild wir dazu ein Dreiecksnetz erzeugt, das mit dem Farbbild als Textur
vom Klient aus der neuen Kameraperspektive synthetisiert wird.

Zu diesem Zweck wurde eine Server- und eine Klient-Komponente entwickelt, die mit
Hilfe des WebSocket-Protokolls Daten untereinander austauschen.
Der Klient basiert auf JavaScript und nutzt für die Bildextrapolation WebGl.
Die Qualität der Darstellungen werden mit Hilfe von Ground-Truth-Daten überprüft.
Zum Vergleich wird der PSNR und der SSIM \cite{Wang04imagequality} der Bildpaare bestimmt und evaluiert.

Im Folgenden werden existierende Konzepte und Ideen vorgestellt.


\chapter{Verwandte Arbeiten}

Einen Überblick über Methoden und Architekturen der interaktiven Remote-Visualisierung geben Shu Shi et al. \cite{Shi:2015:SIR:2775083.2719921}.
Bevor 3D Anwendungen im Fokus der Forschung waren, wurden Desktop und Remote-Anwendungen
sogenannte Thin Client systems entwickelt.
Als Beispiele sollen SLIM \cite{Schmidt:1999:IPS:319344.319154} und THiNC \cite{Baratto:2005:TVD:1095809.1095837} dienen.
Ihre Aufgabe besteht darin Desktop-Systeme fern zusteuern,
zu diesem Zweck wurden sie für den Einsatz von 2D Grafiken optimiert.
Ein Vorteil bei diesen Anwendungen besteht darin, dass nur relativ kleine Änderungen
tatsächlich übertragen werden müssen, wenn sich zum Beispiel ein Fenster ändert muss auch
nur diese Änderung zum Klient übertragen werden.

Ein Remote-Visualisierungssystem lässt sich weiterhin auch als ein verteiltes System betrachten.
Zhefan Jin stellt drei Klassen solcher Systeme vor: sort-first, sort-middle und sort-last
\cite{Jin:2006:RRI:1128923.1128927}.
Die drei Klassen unterscheiden, wann welche Informationen getrennt werden und von
unterschiedlichen Host-Systemen weiter verarbeitet werden.
In Abhängigkeit wie ein solches System konstruiert wurde können Zeicheninstruktionen, Attribute, oder Bilder von einem Knoten zum anderen weiter gereicht werden.
Kompressionsmethoden werden für alle arten von Informationen erläutert.

Peter Eisert und Philipp Fechteler haben ein Remote-Visualisierungssystem
für Computerspiele entwickelt \cite{Eisert07remoterendering}.
Sie haben sich dafür zwei Ansätze zunutze gemacht. 
Im ersten Ansatz erzeugt der Server die fertigen Bilder,
welche mit Video-Codecs codiert und an den Klient gestreamt werden.
Im zweiten Ansatz, werden Zeicheninstruktionen an den Klient gestreamt, welcher mit diesen
das Ergebnissbild produziert.
Ihr System ist für den Einsatz im lokalen Netzwerk konstruiert, trotzdem ist
die Verzögerungszeit von der Eingabe bis zum fertigen Bild zu groß.

Wessels et al. stellen eine Konzeption für den Programmaufbau eines interaktiven Remote-Visualisierungssystem basierend auf dem WebSocket-Protokoll vor \cite{DBLP:conf/itng/WesselsPJR11}.
In ihrem System besteht der Server-Prozess aus zwei Hauptkomponenten,
der Visualisierungs-Engine und dem Deamon. 
Während die Visualisierungs-Engine für die Bildsynthese zuständig ist, 
übernimmt der Deamon die Kommunikation mit dem Klient-Prozess.
Der Klient schickt dabei seine Eingabeinformationen von Maus und Tastatur direkt an den Server.
Dieser wertet die Daten aus und erzeugt darauf hin ein mit JPEG komprimiertes Bild, das mit Base64 kodiert wird und schließlich an den Klient-Prozess geschickt wird. 
Dieser kann das Bild nativ mit Hilfe eines HTML5 Canvas dekodieren und darstellen.
Ihr System wird zur Grundlage dieser Arbeit.

Die Grundidee das Problem der Latenz mit Bildexploration in den Griff zu bekommen wurde in der Arbeit von Palomo et al. betrachtet \cite{Palomo:2010:EAD:1900179.1900236}.


Simon Stegmaier \cite{Stegmaier02ageneric} 
A Generic Solution for Hardware-Accelerated Remote Visualization

Gabriel Taubin und Jarek Rossignac \cite{Taubin:1998:GCT:274363.274365}
Geometric Compression Through
Topological Surgery
Erzeugung von Dreiecksnetzen durch Bäume

Federico Ponchio  und Matteo Dellepiane \cite{Ponchio:2015:FDW:2775292.2775308}
Fast decompression for web-based view-dependent 3D rendering

Gumhold, Stefan and Straßer, Wolfgang \cite{Gumhold:1998:RTC:280814.280836}
Real Time Compression of Triangle Mesh Connectivity

Diplomarbeit mädcheninformatiker Effiziente Datenübertragung von Modellen und
Texturen für die Verwendung in WebGL
Stefan Wagner noch kein cite

Geometry Compression Michael Deering \cite{Deering:1995:GC:218380.218391}

WEB-BASED VISUALISATION OF ON-SET POINT CLOUD
DATA Alun Evans et al \cite{Evans:2014:WVO:2668904.2668937}

planarer scheiß \cite{Ma13ecmr}

\chapter{Grundlagen}

In diesem Kapitel soll es um die Grundlagen der Arbeit gehen. Es wird
vorgestellt wie ein bestehendes Dreiecksnetz aus einer neuen Perspektive
gezeichnet wird und wie die Methoden zum Bildvergleich im Detail funktionieren.

\section{Extrapolation}

Bei dem Zeichenvorgang auf dem Server entsteht ein Farbbild und ein Tiefenbild.
Das Tiefenbild wurde mit einer Farbtiefe von 16bit erzeugt und ist die Ausgangsbasis
für die Bildextrapolation. 
Da aus diesem ein Dreiecksnetz erzeugt wird, welche das Farbbild als Textur verwendet,
und zur Erzeugung neuer Ansichten genutzt wird.
Um das Verfahren besser zu verständlich zu machen,
wird zunächst die Vertex-Transformation näher betrachtet, zu Verdeutlichung der
Zusammenhänge dient die folgende Abbildung:

\begin{figure}[h]
	\begin{tikzpicture}
		\begin{scope}[auto, every node/.style={minimum size=5em, align=center}]
			\node[draw] (A) at (0,0) {Vertex};
			\node[draw] (B) at (4,0) {ModellKamera-\\Matrix};
			
			\node[draw] (C) at (8,0) {Projektion-\\Matrix};
			\node[draw] (D) at (12,0) {Viewport-\\Matrix};
		\end{scope}
		
			\node (B1) at (6,0) {};
			\node (B2) at (6,-2) {Kamera-Koordinaten};
			
			\node (C1) at (10,0) {};
			\node (C2) at (10,-2) {NDC};
			
			\draw[->, line width=1mm] (A) edge (B);
			\draw[->, line width=1mm] (B) edge (C);
			\draw[->, line width=1mm] (C) edge (D);
			
			\draw[->] (B1) edge (B2);
			\draw[->] (C1) edge (C2);
	\end{tikzpicture}
	\centering
	\label{fig:Transformationspipeline}
	\caption{Die Abbildung zeigt die Transformationspipeline, mit deren Hilfe die Vertices
			 auf den Bildschirm abgebildet werden.}
\end{figure}

Die Eingabe der Transformationspipeline ist ein Vertex. Jeder Vertex besteht aus einer x-, y- und einer z-Komponente. 
Die Vertices sind im Modell-Koordinatensystem definiert, das bedeutet, dass der Ursprung
dieses Koordinatensystems das Zentrum des Modells ist.
Durch die Multiplikation mit der Modell-Matrix werden die Vertices in das Weltkoordinatensystem
projiziert.
Um die Koordinaten aus dem Weltkoordinatensystem in das Kamera-Koordinatensystem abzubilden genügt die Multiplikation mit der Kameramatrix.
In der Abbildung \ref{fig:Transformationspipeline} wurde die Modell- und die Kamera-Matrix
zur ModellKamera-Matrix zusammengefasst.
Werden die Vertices, die sich im Kamerakoordinatensystem befinden mit der Projektionsmatrix
multipliziert, dann werden diese in \textit{normalized-device-coordinates}, 
kurz NDC umgewandelt.
Normalisierte-Geräte-Koordinaten haben für die x-,y- und z-Komponente den Wertebereich von
$-1.0$ bis $1.0$. Durch die Multiplikation mit der Viewport-Matrix werden die x- und
 y-Komponente auf die Bildschirmkoordinaten abgebildet.

Um aus dem Tiefenbild normalisierte Gerätekoordinaten zu erhalten, müssen die x- und y-Koordinaten der Pixel durch die Auflösung geteilt werden.
Die Farbwerte des Tiefenbildes liegen im Bereich von $0.0$ bis $1.0$. Je größer der
Wert ist, umso weiter ist ein Pixel von der Bildschirmebene entfernt.
Die Farbwerte müssen ebenfalls in den Wertebereich von $-1.0$ bis $1.0$ überführt werden.

Damit aus den normalisierten Gerätekoordinaten wieder Modellkoordinaten werden,
reicht es aus diese mit der invertierten ModellKameraProjektionsmatrix zu multiplizieren.
Die daraus resultierenden Vertices, lassen sich erneut mit der Transformationspipeline
abbilden, auf diese Weise lassen sich die Koordinaten des einen Bildes in die eines
anderen überführen.

\section{Delaunay-Triangulierung}

Die Delaunay-Triangulierung ist ein Verfahren um ein Dreiecknetz aus einer Menge von
Punkten $p \in \mathbb{R}^{2}$ zu erzeugen.
Dabei wird für jedes Dreieck ein Umkreis erzeugt, innerhalb dessen keine Punkte eines anderen
Dreiecks enthalten sein dürfen.
Jedes Dreieck des zu erzeugenden Netzes muss diese Bedingung erfüllen.
Das Resultat dieser Forderung ist die maximierte Innenwinkelsumme aller Dreiecke.
Für eine gegebene Punktmenge, ist die Lösung nicht eindeutig, es kann verschiedene
Netzkonfigurationen geben, welche die Forderung erfüllen.

 

\section{SSIM}

Image Quality Assessment: From Error Visibility to
Structural Similarity \cite{Wang04imagequality}

\section{PSNR}

\chapter{Ergebnisse}

\begin{figure}[htbp]
	\centering
		\includegraphics{../results/2/512x512_Delaunay/D8/L1.0/I1.0/delaunay.png}
		\includegraphics{../results/2/512x512_Delaunay/D8/L0.5/I0.2/delaunay.png}
	\caption{beschriftung}
	\label{fig:diplominf}
\end{figure}

\chapter{Noch mehr Ergebnisse}

\begin{tikzpicture}
\begin{axis}[axis lines = middle, enlargelimits = true]
\addplot[blue, only marks, mark=x] table [x=a, y=p, col sep=comma] {div_data_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}[axis lines = middle, enlargelimits = true]
\addplot[blue, only marks, mark=x] table [x=a, y=p, col sep=comma] {div_data_mean_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}[axis lines = middle, enlargelimits = true]
\addplot[green, mark=x] table [x=a, y=m, col sep=comma] {div_data_mean_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[red, mark=x] table [x=a, y=m, col sep=comma] {div_data_mean_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[blue, mark=x] table [x=a, y=m, col sep=comma] {div_data_mean_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\end{axis}
\end{tikzpicture}


\vspace*{1cm}

\begin{tikzpicture}
\begin{axis}[axis lines = middle, enlargelimits = true]
\addplot[red, only marks, mark=x] table [x=a, y=r, col sep=comma] {div_data_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[green, only marks, mark=x] table [x=a, y=g, col sep=comma] {div_data_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[blue, only marks, mark=x] table [x=a, y=b, col sep=comma] {div_data_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[black, only marks, mark=x] table [x=a, y=m, col sep=comma] {div_data_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\end{axis}
\end{tikzpicture}

\begin{tikzpicture}
\begin{axis}[axis lines = middle, enlargelimits = true, ylabel=t in ms]
\addplot[green] table [x=i, y=min, col sep=comma]{div_duration_info_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[red] table [x=i, y=max, col sep=comma]{div_duration_info_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[black] table [x=i, y=mean, col sep=comma]{div_duration_info_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\addplot[blue, mark=x] table [x=i, y=d, col sep=comma]{div_duration_info_4_512x512D10L0.0I0.0A0.0J0.0pre.csv};
\end{axis}
\end{tikzpicture}

\begin{figure}
	\centering
	\begin{tikzpicture}
		\begin{axis}[view={0}{90}, 
		 			 grid=major,
		 			 xlabel=$T_{internal}$,
		 			 ylabel=$T_{leaf}$,
		 			 point meta min=0.7, point meta max=0.73,
		 			 colormap={greenyellow}{
		   			 	rgb255(0cm)	 =(128,0,0)
		   			 	rgb255(0.5cm) =(255,255,0) 
		   			 	rgb255(1cm) =(0,200,0)
		 			 }, 
		 			 colorbar, 
		 			 enlargelimits=true, 
		 			 xtick={0.0,0.1,...,1.1},
		     		 ytick={0.0,0.1,...,1.1},
		     		 xmajorgrids=true,
		     		 ymajorgrids=true]
		 
		 \addplot3 [only marks, 
		 		   mark=square*, 
		 		   mark size=7,
		 		   ycomb, 
		 		   scatter] file {div.csv};      
		\end{axis}
	\end{tikzpicture}
\end{figure}

\begin{figure}[h]
	\begin{tikzpicture}
		\begin{scope}[auto, every node/.style={minimum width=15em}]
		 
		\node[draw, fill=lightgray] (A) at (0,0) {Vertex Data};
		
		\node[draw, fill=yellow]	(B) at (0,-1) {Vertex Shader};
		
		\node[draw, fill=lightgray] (C) at (0, -2) {Primitive Assembly};

		\node[draw, fill=lightgray] (D) at (0,-3) {Rasterization};
		
		\node[draw, fill=yellow] 	(E) at (0,-4) {Fragment Shader};
		
		\node[draw, fill=lightgray] (F) at (0,-5) {Per-Fragment Operations};
		
		\node[draw, fill=lightgray] (G) at (0,-6) {Framebuffer};	

		\draw[->, line width=1mm] (A) edge (B);
		\draw[->, line width=1mm] (B) edge (C);
		\draw[->, line width=1mm] (C) edge (D);
		\draw[->, line width=1mm] (D) edge (E);
		\draw[->, line width=1mm] (E) edge (F);
		\draw[->, line width=1mm] (F) edge (G);
		
		\end{scope}
	\end{tikzpicture}
	\centering
\end{figure}

\cite*{}
\end{document}